---
title: 'Feature Overview'
description: 'A high-level map of what RunAgent can do today — and what is coming'
icon: 'rocket'
---

import NeedHelp from '/snippets/need-help.mdx';

> See what RunAgent supports — from serverless deployment to streaming SDKs, security, observability, and agent workflows.

## Start Small, Scale Big

<Cards num={3}>
  <Card title="Deploy & Call in Minutes" href="/tutorials/deploy-your-first-agent" arrow>
    Write one Python function, deploy it, and call it from any language.
  </Card>
  <Card title="Frameworks & Integration" href="/explanation/frameworks-overview" arrow>
    Use LangGraph, CrewAI, or your own custom agent.
  </Card>
  <Card title="SDKs & API" href="/reference/sdk/overview" arrow>
    Full SDKs in Python, JS, Go, Rust; REST/WebSocket APIs with streaming.
  </Card>
</Cards>

---

## Capabilities at a Glance

| Feature | What It Enables |
|---|---|
| **Secure Isolation** | Each agent runs in its own isolated environment for security and resource containment |
| **Automatic Scaling** | RunAgent scales agents automatically under load with fast cold starts |
| **Real-Time Streaming** | Clients receive tokens as they are generated — ideal for chat UIs and interactive applications |
| **Cross-Language Access** | Call the same agent from JavaScript, Go, Python, Rust without extra infrastructure |
| **State & Memory** *(coming soon)* | Agents can optionally hold memory across calls for richer, contextual behavior |
| **Security & Auth** *(in progress)* | Agent-scoped API keys, role-based access, sandbox limits |
| **Telemetry & Observability** *(future)* | Logs, metrics, traces to monitor latency, errors, and usage patterns |
| **Agent-to-Agent (A2A)** *(vision)* | Agents can call and coordinate with other agents for complex workflows |
| **Versioning, Rollbacks, Rate Limits** *(roadmap)* | Control agent versions, limit usage, and revert deployments if needed |

---

## How It Works (High Level)

1. **Write an agent** - Create a Python function with entrypoint configuration  
2. **Deploy serverlessly** - RunAgent handles isolation, sandboxing, and automatic scaling  
3. **Call via SDK / REST / WebSocket** - Use streaming, synchronous calls, across multiple languages  
4. **Monitor & scale** - Track logs, metrics, retries, and rate limits  
5. **Iterate & evolve** - Deploy new versions, add memory, enable agent communication  

---

## Production-Ready Features

<CardGroup cols={2}>
  <Card title="Instant Deployment" icon="bolt">
    Deploy agents to production in seconds with `runagent deploy .` - no infrastructure configuration needed.
  </Card>
  <Card title="Multi-Framework Support" icon="layer-group">
    Works seamlessly with LangGraph, CrewAI, AutoGen, AG2, Letta, and custom frameworks.
  </Card>
  <Card title="Native SDKs" icon="code">
    Python, JavaScript/TypeScript, Go, and Rust SDKs with idiomatic APIs. C++ and C# coming soon.
  </Card>
  <Card title="Built-in Streaming" icon="satellite-dish">
    WebSocket-based streaming works natively across all SDKs with minimal code changes.
  </Card>
</CardGroup>

---

## Next Steps

- Start with **[Deploy your first agent](/tutorials/deploy-your-first-agent)**  
- Explore **[Frameworks & How-tos](/explanation/frameworks-overview)**  
- Dive into **[SDK / API Reference](/reference/sdk/overview)**  
- Or read about **[Architecture & Concepts](/explanation/core-concepts)**

---

<Note>
This page is a **landing overview**. For detailed instructions, go to the linked pages above.
</Note>

<NeedHelp context="Features" />