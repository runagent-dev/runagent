---
title: Introduction
description: 'Deploy AI agents to production in seconds, not hours'
icon: 'book-open'
---

RunAgent is an **AI Agent Deployment Platform**, built for builders who are **using AI agents to empower/enhance their products**. From development to deployment, RunAgent enables the developer to fully focus on actual agent development, and not care about:

- Deploying AI Agents with powerful **RunAgent CLI** with a simple configuration file.
- Spinning up a configurable **REST-API and WebSocket server** for your agents with one cli command.
- **Langugae SDK's** for most major languages, to use the deployed agents.


As a result you, the developer gets the freedom to:

* Focus on the agent development and **avoid repeatative process** of implementing REST and Streaming API to use the agents through.
* Use their developed agent in **any devlopment environment**(Web App, Mobile or Desktop App, Games)
* Build application with **cross language response streaming**, without even thinking about the complex underlying serialization & deserialization logic.


## The Problem Every AI Developer Faces

Suppose, You've built an incredible AI agent in Python. It uses **LangGraph for complex reasoning**, leverages **powerful tools**, and produces **amazing results**. Your team loves it!

### Then reality hits:

Your whole team is excited use it! But the **frontend team** needs to access it in JavaScript, your **mobile app team** wants it in Kotlin, your **Unity team** wants it in good old C#, your **systems team** requires it in Rust. 

### The traditional approach?
Build separate implementations, REST APIs, WebSocket handlers...

**Sound exhausting?** That's because it is!

## What RunAgent Actually Does

RunAgent fundamentally changes how AI agents deployemnt work. Here's the magic:

<img
  className="block dark:hidden"
  src="/images/runagent_dia_light.jpg"
  alt="Hero Light"
/>
<img
  className="hidden dark:block"
  src="/images/runagent_dia_dark.jpg"
  alt="Hero Dark"
/>


Your Python function signatures automatically become API contracts for every supported language:

<CodeGroup>
```python Your Python Agent
# Somewhere in your Agent codebase(Lets assume in `agent/marketer.py`)
def analyze_market(company: str, timeframe: str = "1year") -> dict:
    return langgraph_agent.invoke({"company": company, "timeframe": timeframe})


# You add this in `runagent.config,json` file:
"entrypoints": [
   ...
  {
    "file": "agent/marketer.py",
    "module": "analyze_market",
    "tag": "market_analysis"
  }
]

# And obtain an Agent ID running the CLI command:
runagent serve .
> Agent successfully runnning at: http://localhot:8521
> Agent ID: f7066c98-0eb2-488c-bb37-a869a93d51ce
```

```javascript Becomes JavaScript
import { RunAgentClient } from 'runagent';

const ra = new RunAgentClient({
  agentId: 'f7066c98-0eb2-488c-bb37-a869a93d51ce',
  entrypointTag: 'market_analysis',
  local: true,
});

const analysis = await client.run({
    company: "Tesla",
    timeframe: "6months"
});
```

```rust Becomes Rust  
use runagent::client::RunAgentClient;
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let client = RunAgentClient::new("f7066c98-0eb2-488c-bb37-a869a93d51ce", "market_analysis", true).await?;
    
    let response = client.run(&[
        ("company", json!("Tesla")),
        ("timeframe", json!("6months"))
    ]).await?;
    
    println!("Response: {}", response);
    Ok(())
}
```

```python And Python too 
from runagent import RunAgentClient

ra = RunAgentClient(
    agent_id="f7066c98-0eb2-488c-bb37-a869a93d51ce",
    entrypoint_tag="market_analysis",
    local=True
)

agent_result = ra.run(
    company="Tesla",
    timeframe="6months"
)
```
</CodeGroup>

**The Revolutionary Insight**: Change your Python function signature, and all language SDKs automatically adapt. No API versioning, no breaking changes.

## Getting started

The fastest way to experience the magic is with RunAgent:

1. **Install the CLI** (includes Python SDK):
   ```bash
   pip install runagent
   ```

2. **Create your first agent**:
   ```bash
   runagent init my_agent
   ```

3. **Deploy locally**:
   ```bash
   runagent serve my_agent
   ```
4. **Deploy on RunAgent Cloud(Coming Soon)**:
   ```bash
   runagent deploy my_agent
   ```

...and you're ready to access your Python agent from any supported language.

- Head to the [quickstart](/quickstart) guide to see the full magic
- Browse our [framework templates](/templates) for LangGraph, CrewAI, and more
- Check out [core concepts](/concepts) to understand how it works


## Agent Framework Support

RunAgent works with any Python-based AI agent framework:

<CardGroup cols={3}>
  <Card
    title="LangGraph"
    icon="spider-web"
    href="/frameworks/langgraph"
  >
    Deploy your LangGraph agents with built-in state management and workflow execution.
  </Card>
  <Card 
    title="CrewAI" 
    icon="users" 
    href="/frameworks/crewai"
  >
    Deploy multi-agent CrewAI systems with coordinated execution and monitoring.
  </Card>
  <Card 
    title="AutoGen" 
    icon="robot" 
    href="/frameworks/autogen"
  >
    Deploy Microsoft AutoGen multi-agent conversations with step-by-step execution.
  </Card>
  <Card 
    title="AG2" 
    icon="robot" 
    href="/frameworks/ag2"
  >
    Deploy AG2 conversational agents with fact-checking and multi-turn interactions.
  </Card>
  <Card 
    title="Agno" 
    icon="terminal"
    href="/frameworks/agno"
  >
    Deploy Agno AI agents with print response capabilities and streaming support.
  </Card>
  <Card 
    title="Letta" 
    icon="gear" 
    href="/frameworks/letta"
  >
    Deploy Letta memory-enabled agents with persistent conversations and tool integration.
  </Card>
</CardGroup>
  <Card 
    title="Custom Framework" 
    icon="person-running-fast" 
    href="/frameworks/custom"
    horizontal
  >
    Use any Python-based framework by defining simple entrypoint functions.
  </Card>

## Multi-Language SDK Support

RunAgent provides native-like access to your deployed agents across multiple languages:

<CardGroup cols={2}>
  <Card
    title="Python SDK"
    icon="python"
    href="/sdks/python"
  >
    Python client with streaming capabilities. Access your agents like local functions with full type safety and Python idioms.
  </Card>
  <Card 
    title="JavaScript SDK" 
    icon="js" 
    href="/sdks/javascript"
  >
    Full TypeScript support with streaming and Promise-based APIs. Perfect for modern web applications with async/await patterns.
  </Card>
  <Card 
    title="Rust SDK" 
    icon="rust" 
    href="/sdks/rust"
  >
    High-performance async SDK with futures and streaming support. Zero-cost abstractions for systems programming and performance-critical applications.
  </Card>
  <Card 
    title="Go SDK" 
    icon="golang" 
    href="/sdks/go"
  >
    Idiomatic Go client with context-aware operations and channel-based streaming. Built for concurrent, scalable applications.
  </Card>
</CardGroup>

<Card 
  title="All Language SDKs" 
  icon="code" 
  href="/sdk/overview"
  horizontal
>
  We're actively developing SDKs for additional languages including C#, Java, and PHP. Want to contribute or request a specific language? Join our Discord community.
</Card>


## Real-Time Streaming Across Languages

When your Python agent streams responses, RunAgent makes it feel native in every target language:

<Tabs>
  <Tab title="Python Generator">
    ```python
    def generate_report(topic: str) -> Iterator[str]:
        yield f"# {topic} Analysis Report\n\n"
        yield "## Executive Summary\n"
        for section in analyze_topic(topic):
            yield f"### {section.title}\n{section.content}\n\n"
    ```
  </Tab>
  
  <Tab title="JavaScript Async Iterator">
    ```javascript
    const stream = await client.runStream({topic: "AI Market Trends"});
    for await (const chunk of stream) {
        document.getElementById('report').innerHTML += chunk;
    }
    ```
  </Tab>
  
  <Tab title="Rust Futures Stream">
    ```rust
    let mut stream = client.run_stream(&[("topic", json!("AI Market"))]).await?;
    while let Some(chunk) = stream.next().await {
        println!("{}", chunk?);
    }
    ```
  </Tab>

  <Tab title="Go Stream">
    ```go
    s, err := c.RunStream(ctx, map[string]interface{}{"role": "user", "message": "Analyze the benefits of remote work for software teams"})
	if err != nil {
		log.Fatal(err)
	}
	defer s.Close()

	for {
		data, hasMore, err := s.Next(ctx)
		if err != nil {
			log.Fatal(err)
		}
		if !hasMore {
			break
		}
		fmt.Printf("Received: %v\n", data)
	}
    ```
  </Tab>

</Tabs>

**What's happening**: WebSocket connections, real-time data flow, and native iteration patternsâ€”all handled automatically by RunAgent.

<Card 
    title='View All Features' 
    icon='sparkles' 
    href='/features'
>
Explore streaming, monitoring, security, and enterprise features.
</Card>