<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .agent-info {
            background: rgba(255,255,255,0.1);
            padding: 15px 20px;
            border-radius: 10px;
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .agent-details {
            display: flex;
            gap: 30px;
            font-size: 0.9rem;
        }

        .status-badge {
            background: #dc3545;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .status-badge.ready {
            background: #28a745;
        }

        .status-badge.connecting {
            background: #ffc107;
            color: black;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            min-height: 60vh;
        }

        .input-panel {
            padding: 30px;
            border-right: 1px solid #e9ecef;
            background: #f8f9fa;
        }

        .output-panel {
            padding: 30px;
            display: flex;
            flex-direction: column;
        }

        .form-section {
            margin-bottom: 25px;
        }

        .form-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
            font-size: 0.9rem;
        }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            background: white;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }

        .btn-test {
            background: #17a2b8;
            color: white;
        }

        .btn-test:hover {
            background: #138496;
            transform: translateY(-1px);
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef;
        }

        .output-header h3 {
            color: #2c3e50;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .streaming-indicator {
            display: none;
            background: linear-gradient(90deg, #667eea, #764ba2);
            color: white;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .streaming-indicator.active {
            display: flex;
            align-items: center;
            gap: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .output {
            flex: 1;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', monospace;
            font-size: 13px;
            line-height: 1.6;
            overflow-y: auto;
            white-space: pre-wrap;
            color: #2c3e50;
            max-height: 400px;
        }

        .output::-webkit-scrollbar {
            width: 6px;
        }

        .output::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .output::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }

        .output.welcome {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            font-style: italic;
            text-align: center;
        }

        .output.streaming {
            border-left: 3px solid #007bff;
            background: #f8fbff;
        }

        .output.error {
            border-left: 3px solid #dc3545;
            background: #f8d7da;
            color: #721c24;
        }

        .output.success {
            border-left: 3px solid #28a745;
            background: #d4edda;
            color: #155724;
        }

        .execution-mode {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-button {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e9ecef;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

        .mode-button.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="agentName">Loading Agent...</h1>
            <p id="agentDescription">Connecting to your AI agent...</p>
            
            <div class="agent-info">
                <div class="agent-details">
                    <div><strong>Agent ID:</strong> <span id="agentId">-</span></div>
                    <div><strong>Framework:</strong> <span id="framework">-</span></div>
                    <div><strong>RunAgent Port:</strong> <span id="runagentPort">-</span></div>
                </div>
                <div class="status-badge connecting" id="statusBadge">
                    <span class="loading-spinner"></span> Connecting
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="input-panel">
                <div class="form-section">
                    <h3>üéØ Execution Mode</h3>
                    <div class="execution-mode">
                        <div class="mode-button active" data-mode="standard" onclick="setMode('standard')">
                            ‚ö° Standard
                        </div>
                        <div class="mode-button" data-mode="streaming" onclick="setMode('streaming')">
                            üåä Streaming
                        </div>
                    </div>
                </div>

                <div class="form-section">
                    <h3>üìù Input Fields</h3>
                    <div id="dynamicInputs">
                        <!-- Dynamic input fields will be generated here -->
                    </div>
                </div>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="runAgent()" id="runButton">
                        <span id="runButtonText">Run Agent</span>
                    </button>
                    <button class="btn btn-test" onclick="testConnection()" id="testButton">
                        üîç Test Connection
                    </button>
                    <button class="btn btn-secondary" onclick="clearOutput()">
                        Clear Output
                    </button>
                </div>
            </div>

            <div class="output-panel">
                <div class="output-header">
                    <h3>üì§ Agent Response</h3>
                    <div class="streaming-indicator" id="streamingIndicator">
                        <div class="loading-spinner"></div>
                        <span>Processing...</span>
                    </div>
                </div>
                
                <div class="output welcome" id="output">
                    üëã Welcome to your AI agent interface!
                    
Configure the input fields and click "Run Agent" to get started.

üîç Click "Test Connection" to verify RunAgent server is running.
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentMode = 'standard';
        let isProcessing = false;
        let agentInfo = null;
        let agentId = null;
        let runagentUrl = null;
        let runagentPort = null;

        // Get agent ID from URL
        const urlParams = new URLSearchParams(window.location.search);
        const urlAgentId = urlParams.get('agent');
        
        // Try to extract from path as well (e.g., /agent/123)
        const pathMatch = window.location.pathname.match(/\/agent\/([^\/]+)/);
        agentId = urlAgentId || (pathMatch ? pathMatch[1] : null);

        if (!agentId) {
            // Try to get from fragment
            const fragment = window.location.hash.substring(1);
            agentId = fragment;
        }

        if (agentId) {
            document.getElementById('agentId').textContent = agentId;
        }

        // Initialize the page
        window.addEventListener('DOMContentLoaded', initializePage);

        async function initializePage() {
            if (!agentId) {
                showError("No agent ID provided in URL. Please check the URL format: ?agent=your_agent_id");
                return;
            }

            try {
                console.log('üîç Fetching agent info for ID:', agentId);
                
                // Fetch agent information from the GPT-5 generator backend
                const response = await fetch(`http://localhost:8000/agent/${agentId}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch agent info: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üìã Agent data received:', data);
                
                agentInfo = data.agent_info;
                runagentPort = agentInfo.port;
                runagentUrl = agentInfo.runagent_url || `http://localhost:${runagentPort}`;
                
                console.log('üåê RunAgent URL:', runagentUrl);
                
                // Update UI with agent info
                updateAgentInfo(data);
                
                // Generate input fields based on agent's input fields
                if (agentInfo.input_fields && agentInfo.input_fields.length > 0) {
                    generateInputFields(agentInfo.input_fields);
                } else {
                    // Default fallback if no input fields specified
                    generateInputFields(['message']);
                }
                
                // Test connection immediately
                const connected = await testConnection(false);
                updateConnectionStatus(connected);
                
            } catch (error) {
                console.error('‚ùå Error loading agent:', error);
                showError(`Failed to load agent: ${error.message}`);
            }
        }

        function updateAgentInfo(data) {
            const info = data.agent_info;
            
            document.getElementById('agentName').textContent = info.agent_name || 'Unknown Agent';
            document.getElementById('agentDescription').textContent = info.description || 'AI Agent';
            document.getElementById('framework').textContent = (info.framework || 'custom').toUpperCase();
            document.getElementById('runagentPort').textContent = info.port || 'Unknown';
            
            // Update page title
            document.title = `${info.agent_name || 'Agent'} - RunAgent Interface`;
        }

        function updateConnectionStatus(connected) {
            const statusBadge = document.getElementById('statusBadge');
            if (connected) {
                statusBadge.innerHTML = '‚úÖ Ready';
                statusBadge.className = 'status-badge ready';
            } else {
                statusBadge.innerHTML = '‚ùå Server Down';
                statusBadge.className = 'status-badge';
            }
        }

        function generateInputFields(inputFields) {
            const container = document.getElementById('dynamicInputs');
            container.innerHTML = '';

            inputFields.forEach(field => {
                const group = document.createElement('div');
                group.className = 'form-group';

                const label = document.createElement('label');
                label.textContent = formatFieldName(field);
                label.setAttribute('for', field);

                let input;
                if (field.toLowerCase().includes('query') || 
                    field.toLowerCase().includes('message') || 
                    field.toLowerCase().includes('description') ||
                    field.toLowerCase().includes('text') ||
                    field.toLowerCase().includes('problem') ||
                    field.toLowerCase().includes('prompt') ||
                    field.toLowerCase().includes('task')) {
                    input = document.createElement('textarea');
                    input.className = 'form-control';
                    input.rows = 3;
                } else {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'form-control';
                }

                input.id = field;
                input.name = field;
                input.placeholder = getPlaceholder(field);

                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            });
        }

        function formatFieldName(fieldName) {
            return fieldName
                .replace(/_/g, ' ')
                .replace(/\b\w/g, l => l.toUpperCase());
        }

        function getPlaceholder(field) {
            const placeholders = {
                'message': 'Enter your message here...',
                'query': 'What would you like to know?',
                'prompt': 'Enter your prompt...',
                'task': 'Describe the task...',
                'topic': 'Enter topic of interest',
                'problem_text': 'Enter your problem...',
                'math_query': 'Enter math problem...',
                'user_msg': 'Your message...',
                'text': 'Enter text to process',
                'question': 'Ask your question',
                'input': 'Enter your input'
            };
            
            return placeholders[field.toLowerCase()] || `Enter ${formatFieldName(field).toLowerCase()}`;
        }

        function setMode(mode) {
            currentMode = mode;
            
            document.querySelectorAll('.mode-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
        }

        function collectInputValues() {
            const values = {};
            const inputs = document.querySelectorAll('#dynamicInputs input, #dynamicInputs textarea');
            
            inputs.forEach(input => {
                if (input.value.trim()) {
                    values[input.name] = input.value.trim();
                }
            });
            
            return values;
        }

        async function testConnection(showAlert = true) {
            if (!runagentUrl) {
                if (showAlert) alert('‚ùå No RunAgent URL configured');
                return false;
            }
            
            try {
                console.log('üîç Testing connection to:', runagentUrl);
                
                // Test multiple endpoints to verify server is working
                const endpoints = ['/health', '/docs', '/'];
                let connected = false;
                
                for (const endpoint of endpoints) {
                    try {
                        const testUrl = `${runagentUrl}${endpoint}`;
                        console.log('Testing endpoint:', testUrl);
                        
                        const response = await fetch(testUrl, {
                            method: 'GET',
                            timeout: 5000
                        });
                        
                        if (response.ok) {
                            console.log(`‚úÖ ${endpoint} endpoint responded: ${response.status}`);
                            connected = true;
                            break;
                        }
                    } catch (endpointError) {
                        console.log(`‚ùå ${endpoint} failed:`, endpointError.message);
                    }
                }
                
                if (connected && showAlert) {
                    alert('‚úÖ RunAgent server is reachable!\n\nConnection test passed successfully.');
                }
                
                return connected;
                
            } catch (error) {
                console.error('‚ùå Connection test failed:', error);
                
                if (showAlert) {
                    alert(`‚ùå Cannot reach RunAgent server: ${error.message}\n\nURL: ${runagentUrl}\n\nMake sure the server is running.`);
                }
                return false;
            }
        }

        async function runAgent() {
            if (isProcessing) return;

            const inputValues = collectInputValues();
            
            if (Object.keys(inputValues).length === 0) {
                alert('Please provide at least one input value.');
                return;
            }

            if (!runagentUrl) {
                alert('‚ùå RunAgent server URL not configured');
                return;
            }

            isProcessing = true;
            const runButton = document.getElementById('runButton');
            const runButtonText = document.getElementById('runButtonText');
            const output = document.getElementById('output');
            const streamingIndicator = document.getElementById('streamingIndicator');

            // Update UI for processing
            runButton.disabled = true;
            runButtonText.textContent = currentMode === 'streaming' ? 'Streaming...' : 'Processing...';
            
            if (currentMode === 'streaming') {
                streamingIndicator.classList.add('active');
                output.className = 'output streaming';
                output.textContent = '';
            } else {
                output.className = 'output';
                output.textContent = 'Connecting to RunAgent server...';
            }

            try {
                if (currentMode === 'streaming') {
                    await runStreamingAgent(inputValues);
                } else {
                    await runStandardAgent(inputValues);
                }
            } catch (error) {
                console.error('‚ùå Agent execution error:', error);
                output.textContent = `‚ùå Error: ${error.message}\n\nCheck console for details.`;
                output.className = 'output error';
            } finally {
                isProcessing = false;
                runButton.disabled = false;
                runButtonText.textContent = 'Run Agent';
                streamingIndicator.classList.remove('active');
            }
        }

        async function runStandardAgent(inputValues) {
            const output = document.getElementById('output');
            
            try {
                console.log('üîó Connecting to RunAgent server:', runagentUrl);
                console.log('üìù Sending input:', inputValues);
                
                output.textContent = 'Sending request to agent...';
                
                // Discover available entrypoints first
                const entrypoints = await discoverEntrypoints();
                console.log('üìã Available entrypoints:', entrypoints);
                
                // Find the appropriate entrypoint for standard execution
                const entrypoint = findStandardEntrypoint(entrypoints);
                if (!entrypoint) {
                    throw new Error('No suitable standard entrypoint found. Available: ' + entrypoints.join(', '));
                }
                
                console.log('üéØ Using entrypoint:', entrypoint);
                
                // Make the API call to RunAgent server
                const apiUrl = `${runagentUrl}/agents/${entrypoint}/run`;
                console.log('üì° API URL:', apiUrl);
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(inputValues)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API Error Response:', errorText);
                    throw new Error(`Server responded with ${response.status}: ${errorText}`);
                }

                const result = await response.json();
                console.log('‚úÖ Real agent response:', result);
                
                // Display the REAL response from your agent
                let displayText = '';
                
                if (typeof result === 'string') {
                    displayText = result;
                } else if (result.content) {
                    displayText = result.content;
                } else if (result.result) {
                    displayText = result.result;
                } else if (result.response) {
                    displayText = result.response;
                } else {
                    displayText = JSON.stringify(result, null, 2);
                }
                
                output.textContent = displayText;
                output.className = 'output success';
                
            } catch (error) {
                console.error('‚ùå RunAgent execution failed:', error);
                throw error; // Re-throw to be handled by the main error handler
            }
        }

        async function runStreamingAgent(inputValues) {
            const output = document.getElementById('output');
            
            try {
                console.log('üåä Starting stream to:', runagentUrl);
                
                output.textContent = 'Starting stream...';
                output.className = 'output streaming';
                
                // Discover available entrypoints
                const entrypoints = await discoverEntrypoints();
                console.log('üìã Available entrypoints:', entrypoints);
                
                // Find streaming entrypoint
                const entrypoint = findStreamingEntrypoint(entrypoints);
                if (!entrypoint) {
                    throw new Error('No streaming entrypoint found. Available: ' + entrypoints.join(', '));
                }
                
                console.log('üéØ Using streaming entrypoint:', entrypoint);
                
                const streamUrl = `${runagentUrl}/agents/${entrypoint}/stream`;
                console.log('üì° Stream URL:', streamUrl);
                
                const response = await fetch(streamUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(inputValues)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Stream failed: ${response.status} - ${errorText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                output.textContent = '';
                
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        output.textContent += '\n\n‚úÖ Stream completed';
                        break;
                    }
                    
                    const chunk = decoder.decode(value, { stream: true });
                    console.log('üì¶ Raw chunk:', chunk);
                    
                    // Handle different streaming formats
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.trim()) {
                            try {
                                // Try to parse as SSE format
                                if (line.startsWith('data: ')) {
                                    const data = JSON.parse(line.slice(6));
                                    const content = extractStreamContent(data);
                                    if (content) {
                                        output.textContent += content;
                                        output.scrollTop = output.scrollHeight;
                                    }
                                } else {
                                    // Try to parse as direct JSON
                                    const data = JSON.parse(line);
                                    const content = extractStreamContent(data);
                                    if (content) {
                                        output.textContent += content;
                                        output.scrollTop = output.scrollHeight;
                                    }
                                }
                            } catch (parseError) {
                                // If not JSON, treat as raw text
                                output.textContent += line;
                                output.scrollTop = output.scrollHeight;
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('‚ùå Streaming failed:', error);
                throw error;
            }
        }

        function extractStreamContent(data) {
            // Handle different streaming response formats
            if (typeof data === 'string') return data;
            if (data.content) return data.content;
            if (data.delta) return data.delta;
            if (data.chunk) return data.chunk;
            if (data.text) return data.text;
            if (data.message) return data.message;
            
            // For complex objects, try to extract meaningful content
            if (typeof data === 'object') {
                return JSON.stringify(data) + '\n';
            }
            
            return data;
        }

        async function discoverEntrypoints() {
            try {
                // Try to get entrypoints from the docs endpoint
                const docsUrl = `${runagentUrl}/docs`;
                const response = await fetch(docsUrl);
                
                if (response.ok) {
                    const docsHtml = await response.text();
                    // Extract entrypoint names from OpenAPI docs
                    const entrypointMatches = docsHtml.match(/\/agents\/([^\/]+)\/(run|stream)/g);
                    if (entrypointMatches) {
                        const entrypoints = [...new Set(entrypointMatches.map(match => {
                            const parts = match.split('/');
                            return parts[2]; // Extract entrypoint name
                        }))];
                        return entrypoints;
                    }
                }
            } catch (error) {
                console.warn('Could not discover entrypoints from docs:', error);
            }
            
            // Fallback: try common entrypoint names based on framework
            const framework = agentInfo?.framework?.toLowerCase();
            const commonEntrypoints = [
                'main', 'generic', 'basic', 'invoke', 'run',
                ...(framework ? [`${framework}_invoke`, `${framework}_run`] : [])
            ];
            
            return commonEntrypoints;
        }

        function findStandardEntrypoint(entrypoints) {
            // Prefer non-streaming entrypoints
            const standardPatterns = ['main', 'generic', 'basic', 'invoke', 'run'];
            
            for (const pattern of standardPatterns) {
                for (const entrypoint of entrypoints) {
                    if (entrypoint.toLowerCase().includes(pattern) && 
                        !entrypoint.toLowerCase().includes('stream')) {
                        return entrypoint;
                    }
                }
            }
            
            // Return first non-streaming entrypoint
            return entrypoints.find(ep => !ep.toLowerCase().includes('stream'));
        }

        function findStreamingEntrypoint(entrypoints) {
            // Look for streaming entrypoints (should end with _stream)
            return entrypoints.find(ep => ep.toLowerCase().includes('stream'));
        }

        function showError(message) {
            const output = document.getElementById('output');
            output.textContent = `‚ùå Error: ${message}`;
            output.className = 'output error';
            
            const statusBadge = document.getElementById('statusBadge');
            statusBadge.innerHTML = '‚ùå Error';
            statusBadge.className = 'status-badge';
        }

        function clearOutput() {
            document.getElementById('output').textContent = 'üëã Output cleared. Ready for new request.';
            document.getElementById('output').className = 'output welcome';
        }

        // Auto-focus first input when page loads
        setTimeout(() => {
            const firstInput = document.querySelector('#dynamicInputs input, #dynamicInputs textarea');
            if (firstInput) {
                firstInput.focus();
            }
        }, 1000);
    </script>
</body>
</html>