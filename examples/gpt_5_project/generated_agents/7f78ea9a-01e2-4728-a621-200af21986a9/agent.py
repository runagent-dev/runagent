"""
research_write_assistant - A research writing agent that takes key research parameters and produces structured, citation-aware drafts and summaries. It supports outlining, literature sourcing, drafting sections, and generating reference lists based on provided depth and source constraints.
Generated by RunAgent Generator
"""

from typing import List, TypedDict, Any
from langchain_core.messages import HumanMessage
from langchain_openai import ChatOpenAI
from langgraph.graph import END, StateGraph

class AgentState(TypedDict):
    input_data: dict
    result: str

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.3)

def process_agent(state: AgentState) -> AgentState:
    """Main processing function for research_write_assistant"""
    
    input_data = state.get('input_data', {})
    
    # Extract relevant inputs
    extracted_info = []
    for field in ["topic", "depth", "target_audience", "sections", "preferred_sources", "citation_style", "max_length", "deadline"]:
        if field in input_data:
            extracted_info.append(f"{field}: {input_data[field]}")
    
    input_summary = "\n".join(extracted_info) if extracted_info else "No specific input provided"
    
    prompt = f"""
    A research writing agent that takes key research parameters and produces structured, citation-aware drafts and summaries. It supports outlining, literature sourcing, drafting sections, and generating reference lists based on provided depth and source constraints.
    
    Main functionality: Generate structured research drafts and literature-backed summaries from minimal input parameters
    
    User input:
    {input_summary}
    
    Please provide a helpful response based on this agent's purpose.
    """
    
    response = llm.invoke([HumanMessage(content=prompt)])
    
    return {**state, "result": response.content}

def create_workflow():
    """Create the agent workflow"""
    workflow = StateGraph(AgentState)
    
    workflow.add_node("process", process_agent)
    workflow.set_entry_point("process") 
    workflow.add_edge("process", END)
    
    return workflow.compile()

# Create workflow
app = create_workflow()

def main(*input_args, **input_kwargs):
    """Main entry point for RunAgent (standard)"""
    
    # Run the workflow
    result = app.invoke({
        "input_data": input_kwargs,
        "result": ""
    })
    
    return result["result"]

def main_stream(*input_args, **input_kwargs):
    """Streaming entry point"""
    
    try:
        for chunk in app.stream({
            "input_data": input_kwargs,
            "result": ""
        }):
            if "result" in chunk.get("process", {}):
                yield chunk["process"]["result"]
            else:
                yield str(chunk)
    except Exception as e:
        yield f"Error: {str(e)}"
