# .github/workflows/create-release.yml
name: Create GitHub Release and Publish SDKs
on:
  push:
    branches: [main]  # Trigger on ANY push to main (including PR merges)
jobs:
  detect-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event.pull_request.merged == true)
    outputs:
      latest_tag: ${{ steps.find-tags.outputs.latest_tag }}
      version: ${{ steps.find-tags.outputs.version }}
      should_release: ${{ steps.check-release.outputs.should_release }}
    permissions:
      contents: write
      pull-requests: read
      issues: read
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history to find tags
    
    - name: Find new tags reachable from main
      id: find-tags
      run: |
        echo "ðŸ” [MAIN RELEASE] Checking for version tags now reachable from main..."
        
        # Get all version tags
        ALL_TAGS=$(git tag -l 'v*' | sort -V)
        echo "All version tags: $ALL_TAGS"
        
        # Find tags that are reachable from main
        REACHABLE_TAGS=""
        for tag in $ALL_TAGS; do
          TAG_COMMIT=$(git rev-list -n 1 $tag)
          if git merge-base --is-ancestor $TAG_COMMIT HEAD; then
            echo "âœ… Tag $tag is reachable from main (commit: $TAG_COMMIT)"
            REACHABLE_TAGS="$REACHABLE_TAGS $tag"
          else
            echo "âŒ Tag $tag is NOT reachable from main (commit: $TAG_COMMIT)"
          fi
        done
        
        echo "reachable_tags=$REACHABLE_TAGS" >> $GITHUB_OUTPUT
        
        # Find the latest reachable tag
        if [ -n "$REACHABLE_TAGS" ]; then
          LATEST_TAG=$(echo $REACHABLE_TAGS | tr ' ' '\n' | sort -V | tail -1)
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "ðŸ·ï¸ Latest reachable tag: $LATEST_TAG"
          
          # Extract version
          VERSION=${LATEST_TAG#v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
        else
          echo "No version tags reachable from main"
          echo "latest_tag=" >> $GITHUB_OUTPUT
          echo "version=" >> $GITHUB_OUTPUT
        fi
    
    - name: Check if this is a new release
      id: check-release
      run: |
        LATEST_TAG="${{ steps.find-tags.outputs.latest_tag }}"
        
        if [ -z "$LATEST_TAG" ]; then
          echo "No tags found, skipping release"
          echo "should_release=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Check if we already created a release for this tag
        if gh release view "$LATEST_TAG" >/dev/null 2>&1; then
          echo "Release for $LATEST_TAG already exists, skipping"
          echo "should_release=false" >> $GITHUB_OUTPUT
        else
          echo "ðŸš€ New tag $LATEST_TAG detected, should create release"
          echo "should_release=true" >> $GITHUB_OUTPUT
        fi
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
  publish-python:
    name: Publish Python SDK
    needs: detect-release
    if: needs.detect-release.outputs.should_release == 'true'
    uses: ./.github/workflows/python-release.yml
    permissions:
      contents: read
    with:
      working-directory: .
      tag: ${{ needs.detect-release.outputs.latest_tag }}
      version: ${{ needs.detect-release.outputs.version }}
    secrets: inherit

  publish-typescript:
    name: Publish TypeScript SDK
    needs: detect-release
    if: needs.detect-release.outputs.should_release == 'true'
    uses: ./.github/workflows/typescript-release.yml
    permissions:
      contents: read
      id-token: write
    with:
      working-directory: runagent-ts
      tag: ${{ needs.detect-release.outputs.latest_tag }}
      version: ${{ needs.detect-release.outputs.version }}
    secrets: inherit

  publish-rust:
    name: Publish Rust SDK
    needs: detect-release
    if: needs.detect-release.outputs.should_release == 'true'
    uses: ./.github/workflows/rust-release.yml
    permissions:
      contents: read
      id-token: write
    with:
      working-directory: runagent-rust/runagent
      tag: ${{ needs.detect-release.outputs.latest_tag }}
      version: ${{ needs.detect-release.outputs.version }}
    secrets: inherit

  publish-go:
    name: Publish Go SDK
    needs: detect-release
    if: needs.detect-release.outputs.should_release == 'true'
    uses: ./.github/workflows/go-release.yml
    permissions:
      contents: read
    with:
      working-directory: runagent-go
      tag: ${{ needs.detect-release.outputs.latest_tag }}
      version: ${{ needs.detect-release.outputs.version }}
    secrets: inherit

  create-release:
    name: Create GitHub Release
    needs:
      - detect-release
      - publish-python
      - publish-typescript
      - publish-rust
      - publish-go
    if: needs.detect-release.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract changelog for version
        id: extract-changelog
        run: |
          VERSION="${{ needs.detect-release.outputs.version }}"
          TAG="${{ needs.detect-release.outputs.latest_tag }}"
          
          # Function to extract changelog section
          extract_section() {
            local pattern="$1"
            # Extract from the pattern to the next ## or end of file
            awk -v pattern="$pattern" '
              /^## \[/ { 
                if (found) exit
                if ($0 ~ pattern) { found=1; next }
              }
              found { print }
            ' CHANGELOG.md | sed '/^<!-- generated by git-cliff -->/d'
          }
          
          # Try to find the changelog section
          CHANGELOG_CONTENT=""
          
          if grep -q "## \[$VERSION\]" CHANGELOG.md; then
            CHANGELOG_CONTENT=$(extract_section "\\[$VERSION\\]")
          elif grep -q "## \[$TAG\]" CHANGELOG.md; then
            CHANGELOG_CONTENT=$(extract_section "\\[$TAG\\]")
          else
            # Fallback: get the first version section (usually the latest)
            CHANGELOG_CONTENT=$(awk '/^## \[/,/^## \[|^$/' CHANGELOG.md | tail -n +2 | head -n -1 | sed '/^<!-- generated by git-cliff -->/d')
          fi
          
          # If still empty, provide a default message
          if [ -z "$CHANGELOG_CONTENT" ]; then
            CHANGELOG_CONTENT="No changelog entries found for this version."
          fi
          
          # Output using multiline format for GitHub Actions
          {
            echo 'changelog<<CHANGELOG_EOF'
            echo "$CHANGELOG_CONTENT"
            echo 'CHANGELOG_EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Create main GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.detect-release.outputs.latest_tag }}
          name: RunAgent v${{ needs.detect-release.outputs.version }}
          body: |
            # ðŸš€ RunAgent v${{ needs.detect-release.outputs.version }}

            **Universal AI Agent Platform - All SDKs synchronized at v${{ needs.detect-release.outputs.version }}**

            ## ðŸ“‹ What's New

            ${{ steps.extract-changelog.outputs.changelog }}

            ## ðŸ“¦ Installation

            ```bash
            pip install runagent==${{ needs.detect-release.outputs.version }}
            ```

            ```bash
            npm install @runagent/sdk@${{ needs.detect-release.outputs.version }}
            ```

            ```bash
            cargo add runagent@${{ needs.detect-release.outputs.version }}
            ```

            ```bash
            go get github.com/runagent-dev/runagent-go@${{ needs.detect-release.outputs.latest_tag }}
            ```

            ---

            For the full changelog, see [CHANGELOG.md](./CHANGELOG.md).

          draft: false
          prerelease: false
          generate_release_notes: false
          files: |
            CHANGELOG.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}